---
{"dg-publish":true,"permalink":"/laboration-datorteknik-4/","tags":["laboration","datorteknik"]}
---



This lab is about Interrupt Handling. The goal is to understand how to use interrupts and learn how to write interrupt service routines. 

We need to write a state machine

first we can do polling, then it's a security systems run - function from library does stuff in the background to simulate other processes going on. The whole point is to see the difference between polling and interrupts. 

Write the code with polling, and avoid while loops. Keep some kind of state variable. Use a switch case. Then we replace it with interrupts. We can put the whole code in a interrupt routine, which is not the best solution but it works. The longer our interrupt routine is the higher the chance that we miss another input. Better solution: simply change the state of a variable in the interrupt and let the main program read those variables. 


# Interrupt Handling
The normal going of the program gets interrupted at some point.

When a processor wants to go to the next instruction it checks if there is an interrupt.

In polling the program checks if the evice I/O is ready. It wastes many clock cycles, since we need to load in a value from the register and perform other operations. Only if you don't want to do anything else other than read a button then polling works fine, but otherwise it's a really bad idea since we can miss button presses. Interrupts are a solution to this problem

# Interrupts
Interrupts are external events that need immediate attention from the processor. The processor receives interrupts through its interrupt request lines. When an interrupt occurs and interrupts are enabled we
1. Allow the current instructiont o complete its execution
2. Store the address of the next instruction to be executed (return address) in a dedicated register
3. PC is loaded with the memory address of a particular routine, i.e interrupt service routine (Interrupt Handler)

In other words a subroutine is called. The status register is also saved to the stack - important!

> [!Important]  Interrupts help to reduce power consumtion and increase battery life

When a device is sleeping the clock is basically disabled, and an interrupt is used to wake the device again. â€“ Very important for IoT stuff.


# Polling vs Interrupt
Polling a UART Receive results in 100% CPU load while using Interrupt is less than 0.1% CPU load!

Basically: Interrupts >> Polling. all my homies hate polling.

# Interrupt Service Routine (Assembly)

1. Update the stack pointer
2. Store all register (including status register) on the stack
3. Service the interrupt
4. Restore the registers
5. Return from interrupt

# How to enable interrupts on AVR
Interrupts are enabled if bit 7 is set to 1. When an interrupt is handled the flag is set to 0, and then set to 1 again when returned from interrupt. 

It is different for every processor.

![Pasted image 20230223153624.png](/img/user/images/Pasted%20image%2020230223153624.png)

# AVR Interrupt Types
- Internal Interrupts - generated by internal peripheral devices
	- Timers
	- USART, SPI
	- ADC, analog comparator
- External Interrupts - External signals connected to uC
	- Optosensors
	- Buttons

There are multiple external input interrupt request lines.
INT0-INT2 are edge triggered
PCINT0-32 are pin change interupts. It's the ones we will use in the lab.

# Pin Change Interrupt Control Register
PCICR. 
![Pasted image 20230223154309.png](/img/user/images/Pasted%20image%2020230223154309.png)

We can select wether pin change interrupt is enabled on respective I/O pin using the Pin Change Mask Register (PCMSK). In lab 4 we only want to use PCINT23 and PCINT22, so we should use PCMSK to only activate interrupts for those. When we get an interrupt we know that the pin has changed, and need to read the value from the pin.

# Interrupt Vectors
Whenever interrupt is detcted the processor pushes PC onto stack and jumps to a predefined address in program memory.
![Pasted image 20230223154453.png](/img/user/images/Pasted%20image%2020230223154453.png)
This is done automatically in the background in our case (lab 4).